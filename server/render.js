import path from 'path';
import fs from 'fs';
import url from 'url';

import assign from 'lodash/object/assign';
import cloneDeep from 'lodash/lang/cloneDeep';
import result from 'lodash/object/result';
import findLast from 'lodash/collection/findLast';
import React from 'react';
import Router from 'react-router';
import { pathToLocale } from '../app/helpers/locale-helper/locale-helper';
import HtmlDocument from '../app/components/html-document/html-document';
import { getRoutes, getLocalesForRouteName } from '../app/router/route-helpers';
import localeMessages from '../config/messages';
import availableLocales from '../config/available-locales';
import config from '../config';
import formats from '../config/formats';
import { getMessage } from '../app/components/intl/intl';

/**
 * Returns a JSON array with paths to JS and CSS file, generated by webpack.
 */
function getWebpackPaths() {
  return JSON.parse(fs.readFileSync(path.join(__dirname, '..', 'app', 'bundles', 'webpack-stats.json')));
}

/**
 * Cleans up the pathname part of the url.
 * @param  {String} urlStr Url string to clean.
 * @return {String}        Returns cleaned up url.
 */
function normalizeUrl(urlStr) {
  // Creates an object out of the url string.
  var parsedUrl = url.parse((urlStr || '').toLowerCase());
  // Removes slashes at the beginning and end of pathname.
  parsedUrl.pathname = parsedUrl.pathname.replace(/^\/|\/$/g, '');
  // Adds back slashes or replaces pathname with a single slash if it was falsy.
  parsedUrl.pathname = parsedUrl.pathname ? `/${parsedUrl.pathname}/` : '/';
  // Returns back the url string.
  return url.format(parsedUrl);
}

/**
 * Middle ware used to serve HTML content rendered based on the react-router path.
 * Content is rendered in form of the index.html page created as a react component.
 * @param  {Object}   req  Express request object.
 * @param  {Object}   res  Express response object.
 * @param  {Function} next Callback passing control to the next handler.
 */
export function render(req, res, next) {
  // Checking if request is for HTML content.
  const isHtml = req.headers.accept && req.accepts('html');

  // Skip not found assets
  // If not request for HTML content, pass control to the next handler.
  if (!isHtml) { return next(); }

  // Gets the normalized url.
  const reqUrl = normalizeUrl(req.url);
  // Takes the pathname togother with query parameters.
  const reqPath = url.parse(reqUrl).path;
  // Gets the language definition object identified in the given path, or the default one if no language code found in the path.
  const reqLocale = pathToLocale(reqPath, availableLocales);
  // Gets the react-router configuration components of all routes for a given locale.
  const routes = getRoutes(reqLocale.normalized, availableLocales);
  // Gets all messages for a given locale code.
  const messages = cloneDeep(localeMessages[reqLocale.normalized]);

  // Gets all country names for all locales.
  const availableCountryNames = availableLocales.reduce(function(memo, locale) {
    memo[locale] = getMessage(localeMessages[locale], 'country');
    return memo;
  }, {});

  // Merges locale props with state props.
  function appProps(props) {
    return assign({
      currentLocale: reqLocale.normalized,
      language: reqLocale.language,
      messages: messages,
      formats: formats,
      config: config,
      availableLocales: availableLocales,
      availableCountryNames: availableCountryNames,
    }, props);
  }

  // Creates a new react-router object, with routes config, and current url.
  const router = Router.create({
    onAbort: function(abortReason) {
      next(abortReason);
    },
    onError: function(err) {
      next(err);
    },
    routes: routes,
    location: reqUrl,
  });

  // Generates a handler for current route path.
  router.run(function(Handler, state) {
    // Gets the name of given route.
    const routeName = result(findLast(state.routes.slice(), 'name'), 'name');
    // Gets all available locales for a given route name.
    const routeLocales = Object.keys(getLocalesForRouteName(routeName, availableLocales) || {});
    // Generates new state properties.
    const stateProps = {
      routeName: routeName || 'not_found',
      pathname: state.pathname,
      routeLocales: routeLocales,
    };

    // Generates the requested page markup.
    const markup = React.renderToString(<Handler {...appProps(stateProps)} />);
    // Gets JS and CSS paths of files generated by webpack.
    const webpackUrls = getWebpackPaths();

    // The application component is rendered to static markup
    // and sent as response.
    const html = React.renderToStaticMarkup(
      <HtmlDocument
        markup={markup}
        script={webpackUrls.script}
        css={webpackUrls.css}
        router={router}
        dataRender={appProps(stateProps)}
        {...appProps(stateProps)} />
    );
    const doctype = '<!DOCTYPE html>';
    res.send(doctype + html);
  });
}
